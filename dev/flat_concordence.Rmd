---
title: "flat_concordence.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
library(irr)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.
-->

## cohen_agreement
    
```{r function-cohen_agreement}
#' Cohen agreement
#' 
#' Calculates Cohen's kappa and generates a table including number of positive and negative agreement, as well as positive, negative,  overall percent agreements, and the Kappa value.
#' 
#' @param data_var data table 
#' @param var1 The test with "Positive" and "Negative"results.
#' @param var2 The comparator with "Positive" and "Negative"results.
#'
#' @return Data table
#' 
#' @import checkmate
#' @import dplyr
#' @importFrom irr kappa2
#' @export
cohen_agreement <- function(data_var, var1, var2){

  kappa_val      <- format(round(kappa2(data_var[, c(var1, var2)])$value, 2), nsmall = 2)
  All_pos        <- data_var %>% filter_at(vars(c(var1, var2)), all_vars(. == 'Positive')) %>% dplyr::count()
  All_neg        <- data_var %>% filter_at(vars(c(var1, var2)), all_vars(. == 'Negative')) %>% dplyr::count()
  testP_compN    <- data_var %>% filter_at(vars(var1) , all_vars(. == 'Positive')) %>% filter_at(vars(var2) , all_vars(. == 'Negative')) %>% dplyr::count()
  testN_compP    <- data_var %>% filter_at(vars(var1) , all_vars(. == 'Negative')) %>% filter_at(vars(var2) , all_vars(. == 'Positive')) %>% dplyr::count()
  TOT            <- All_pos + All_neg + testP_compN + testN_compP
  perc_agreement <- as.numeric(format(round(100*(All_pos+All_neg)/(TOT), 1), nsmall = 1))
  PPA            <- as.numeric(format(round(100*(All_pos/(All_pos+testN_compP)), 1), nsmall=1))
  NPA            <- as.numeric(format(round(100*(All_neg/(All_neg+testP_compN)), 1), nsmall=1))
  ci_ppa         <- round(CI_Calc(0.05, PPA/100, as.numeric(All_pos+testN_compP))*100, 1)
  ci_npa         <- round(CI_Calc(0.05, NPA/100, as.numeric(All_neg+testP_compN))*100, 1)
  ci_apa         <- round(CI_Calc(0.05, perc_agreement/100, as.numeric(TOT))*100, 1)
  L_PPA          <- round(PPA - ci_ppa,1)
  U_PPA          <- ifelse((PPA + ci_ppa) < 100, round(PPA + ci_ppa,1), 100)
  L_NPA          <- round(NPA - ci_npa,1)
  U_NPA          <- ifelse((NPA + ci_npa) < 100, round(NPA + ci_npa,1), 100)
  L_perc_agree   <- round(perc_agreement - ci_apa,1)
  U_perc_agree   <- ifelse((perc_agreement + ci_apa) < 100, round(perc_agreement + ci_apa,1), 100)
  data_return    <- c(`All Positive` = All_pos, `Test(+) Comp(-)` = testP_compN, `Test(-) Comp(+)` = testN_compP,`All Negative` = All_neg,
                      `NPA` = NPA, `Lower bound 95% CI NPA` = L_NPA, `Upper bound 95% CI NPA` = U_NPA,
                      `PPA` = PPA,  `Lower bound 95% CI PPA` = L_PPA, `Upper bound 95% CI PPA` = U_PPA,
                      `Percentage of agreement` = perc_agreement,`Lower bound 95% CI Overall PA` = L_perc_agree, `Upper bound 95% CI Overall PA` = U_perc_agree,`Cohen's Kappa` = kappa_val)
  
  data_return    <- as.data.frame(t(data_return))
  
  return(data_return)
}
```
  
```{r example-cohen_agreement}

df <- data.frame(Test1 = c(rep("Positive", 20), rep("Negative", 20)), Test2 = c(rep("Positive", 30), rep("Negative", 10)))
cohen_agreement(data_var = df, var1 = "Test1", var2 = "Test2")

```
  
```{r tests-cohen_agreement}

df <- data.frame(Test1 = c(rep("Positive", 20), rep("Negative", 20)), Test2 = c(rep("Positive", 30), rep("Negative", 10)))
results <- cohen_agreement(data_var = df, var1 = "Test1", var2 = "Test2")

test_that("cohen_agreement works", {expect_data_frame(results)})


```

## Format Column Names (for the data table produced by cohen_agreement)
    
```{r function-format_colnames}
#' format_colnames
#' 
#' Edits the column names of the table generated by cohen_agreement, to make it more explicit.
#' 
#' @param data_frame the data table generated by cohen_agreement
#' @param test1 Names of the test
#' @param test2 Name of the comparator
#'
#' @return Returns nicely formatted colnames
#' 
#' @export
format_colnames <- function(data_frame, test1, test2){
  colnames(data_frame) <-
    c(
      "All Positive",
      paste0(test1,"(+) ", test2,"(-)"),
      paste0(test1,"(-) ", test2,"(+)") ,
      "All Negative",
      "NPA",
      "Lower bound 95% CI NPA",
      "Upper bound 95% CI NPA" ,
      "PPA",
      "Lower bound 95% CI PPA",
      "Upper bound 95% CI PPA",
      "Overall PA",
      "Lower bound 95% CI Overall PA",
      "Upper bound 95% CI Overall PA",
      "Cohen's Kappa"
    )
  return(data_frame)
}
```
  
```{r example-format_colnames}

df <- data.frame(Test1 = c(rep("Positive", 20), rep("Negative", 20)), Test2 = c(rep("Positive", 30), rep("Negative", 10)))
results <- cohen_agreement(data_var = df, var1 = "Test1", var2 = "Test2")
print(results)
format_colnames(data_frame = results, test1 = "This Test", test2 = "The Other Test")
```
  
```{r tests-format_colnames}

```
  

## group_means_concordence 
    
```{r function-group_means_concordence}
#'  Group Means - Supplement for Concordance Analysis
#' 
#' Calculate group means of a continuous variable of interest in all possible combinations if agreements between three reference columns
#' 
#' @param data_var The data table
#' @param mean_var The continuous variable from which the mean will be calculated
#' @param var1 A bifactor variable with "Positive" and "Negative" results.
#' @param var2 A bifactor variable with "Positive" and "Negative" results.
#' @param var3 A bifactor variable with "Positive" and "Negative" results.
#'
#' @return Mean of a numeric column based on groups defined by combination of three reference columns 
#' 
#' @import checkmate
#' @import dplyr
#' @export
group_means_concordence <- function(data_var, mean_var, var1, var2, var3) {
  All_pos        <- data_var %>% filter_at(vars(c(var1, var2, var3)), all_vars(. == 'Positive'))
  All_neg        <- data_var %>% filter_at(vars(c(var1, var2, var3)), all_vars(. == 'Negative'))
  v1P_v2N_v3N    <- data_var %>% filter_at(vars(var1) , all_vars(. == 'Positive')) %>% filter_at(vars(var2) , all_vars(. == 'Negative')) %>% filter_at(vars(var3) , all_vars(. == 'Negative'))
  v1N_v2P_v3N    <- data_var %>% filter_at(vars(var1) , all_vars(. == 'Negative')) %>% filter_at(vars(var2) , all_vars(. == 'Positive')) %>% filter_at(vars(var3) , all_vars(. == 'Negative'))
  v1N_v2N_v3P    <- data_var %>% filter_at(vars(var1) , all_vars(. == 'Negative')) %>% filter_at(vars(var2) , all_vars(. == 'Negative')) %>% filter_at(vars(var3) , all_vars(. == 'Positive'))
  v1P_v2P_v3N    <- data_var %>% filter_at(vars(var1) , all_vars(. == 'Positive')) %>% filter_at(vars(var2) , all_vars(. == 'Positive')) %>% filter_at(vars(var3) , all_vars(. == 'Negative'))
  v1N_v2P_v3P    <- data_var %>% filter_at(vars(var1) , all_vars(. == 'Negative')) %>% filter_at(vars(var2) , all_vars(. == 'Positive')) %>% filter_at(vars(var3) , all_vars(. == 'Positive'))
  v1P_v2N_v3P    <- data_var %>% filter_at(vars(var1) , all_vars(. == 'Positive')) %>% filter_at(vars(var2) , all_vars(. == 'Negative')) %>% filter_at(vars(var3) , all_vars(. == 'Positive'))
  #browser()
  data_to_return <- data.frame(Groups = c("All_pos", "All_neg", "v1P_v2N_v3N", "v1N_v2P_v3N", "v1N_v2N_v3P","v1P_v2P_v3N", "v1N_v2P_v3P", "v1P_v2N_v3P"),
                               Mean = c(mean(All_pos[,mean_var], na.rm = TRUE), mean(All_neg[,mean_var], na.rm = TRUE), mean(v1P_v2N_v3N[,mean_var], na.rm = TRUE), mean(v1N_v2P_v3N[,mean_var], na.rm = TRUE), mean(v1N_v2N_v3P[,mean_var], na.rm = TRUE), mean(v1P_v2P_v3N[,mean_var], na.rm = TRUE), mean(v1N_v2P_v3P[,mean_var], na.rm = TRUE), mean(v1P_v2N_v3P[,mean_var], na.rm = TRUE)),
                               Stdev = c( sd(All_pos[,mean_var], na.rm = TRUE),sd(All_neg[,mean_var], na.rm = TRUE),sd(v1P_v2N_v3N[,mean_var], na.rm = TRUE),sd(v1N_v2P_v3N[,mean_var], na.rm = TRUE),sd(v1N_v2N_v3P[,mean_var], na.rm = TRUE),sd(v1P_v2P_v3N[,mean_var]),sd(v1N_v2P_v3P[,mean_var], na.rm = TRUE),sd(v1P_v2N_v3P[,mean_var], na.rm = TRUE)))
  return(data_to_return)

}
```
  
```{r example-group_means_concordence}

df <- data.frame(Test1 = c(rep("Positive", 20), rep("Negative", 20)), Test2 = c(rep("Negative", 5), rep("Positive", 5), rep("Negative", 30)), Test3 = c(rep("Positive", 10), rep("Negative", 25), rep("Positive", 5)), MyVariable = sample(1:100, 40))


group_means_concordence(data_var = df, mean_var = "MyVariable", var1 = "Test1", var2 = "Test2", var3 = "Test3")

```
  
```{r tests-group_means_concordence}
df <- data.frame(Test1 = c(rep("Positive", 20), rep("Negative", 20)), Test2 = c(rep("Negative", 5), rep("Positive", 5), rep("Negative", 30)), Test3 = c(rep("Positive", 10), rep("Negative", 25), rep("Positive", 5)), MyVariable = sample(1:100, 40))


res<-group_means_concordence(data_var = df, mean_var = "MyVariable", var1 = "Test1", var2 = "Test2", var3 = "Test3")

test_that("cohen_agreement works", {expect_data_frame(res)})
```
  


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_concordence.Rmd", vignette_name = "Concordance")
```
